'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var t = _ref['types'];

  // Tracking variables build during the AST pass. We instantiate
  // these in the `Program` visitor in order to support running the
  // plugin in watch mode or on multiple files.
  var lodashObjs = void 0,
      fpObjs = void 0,
      fpSpecified = void 0,
      specified = void 0,
      selectedMethods = void 0;

  var CHAIN_ERROR = 'lodash chaining syntax is not supported by babel-plugin-lodash.\nConsider substituting the chaining syntax with _.flow and _.flowRight composition patterns.\nSee https://medium.com/making-internets/why-using-chain-is-a-mistake-9bc1f80d51ba';

  // Import a lodash method and return the computed import identifier.
  // The goal of this function is to only import a method+base pair once
  // per program. It is safe to reuse import identifiers.
  function importMethod(methodName, file, base) {
    var importName = arguments.length <= 3 || arguments[3] === undefined ? methodName : arguments[3];

    // methodPath is used to create a unique identifier of a method+base pair
    // in order to track the source of the import. This is useful, for example,
    // if the program includes fp/map and lodash/map (fp/ is one base whereas */ is the other)
    var methodPath = (base || '*') + '/' + methodName;
    if (!selectedMethods[methodPath]) {
      var importPath = (0, _lodashModules2.default)(methodName, base);
      selectedMethods[methodPath] = file.addImport(importPath, 'default', importName);
    }
    return selectedMethods[methodPath];
  }

  return {
    'visitor': {

      // Instantiate all the necessary tracking variables for this AST.
      'Program': {
        enter: function enter() {
          // Track the variables used to import lodash.
          lodashObjs = Object.create(null);
          specified = Object.create(null);

          // Trackers for lodash-fp support.
          fpObjs = Object.create(null);
          fpSpecified = Object.create(null);

          // Track the methods that have already been used to prevent dupe imports.
          selectedMethods = Object.create(null);
        }
      },

      ImportDeclaration: function ImportDeclaration(path) {
        var node = path.node;
        var value = node.source.value;

        var fp = value == 'lodash/fp';
        var file = path.hub.file;


        if (fp || value == 'lodash') {
          // Remove the original import node, for replacement.
          path.remove();

          // Start tracking all the import specifiers and default instances
          // of lodash imported in the program
          node.specifiers.forEach(function (spec) {
            if (t.isImportSpecifier(spec)) {
              // handle import specifier (i.e. `import {map} from 'lodash'`)
              var importBase = fp ? 'fp' : null;
              (fp ? fpSpecified : specified)[spec.local.name] = importMethod(spec.imported.name, file, importBase, spec.local.name);
            } else {
              // handle default specifier (i.e. `import _ from 'lodash'`)
              (fp ? fpObjs : lodashObjs)[spec.local.name] = true;
            }
          });
        }
      },
      CallExpression: function CallExpression(path) {
        var node = path.node;
        var name = node.callee.name;

        // Update the referenced import specifier if its marked for replacement

        if (specified[name]) {
          node.callee = specified[name];
        } else if (fpSpecified[name]) {
          node.callee = fpSpecified[name];
        }
        // Detect chaining via _(value).
        else if (lodashObjs[name]) {
            throw new Error(CHAIN_ERROR);
          }

        // Support lodash methods used as call parameters (#11)
        // e.g. _.flow(_.map, _.head)
        if (node.arguments) {
          node.arguments = node.arguments.map(function (arg) {
            var name = arg.name;
            // Assume that is supposed to be a placeholder (#33)

            if (lodashObjs[name] || fpObjs[name]) {
              return t.memberExpression(node.callee, t.identifier('placeholder'));
            }
            // Support fp methods as arguments (#40)
            return specified[name] || fpSpecified[name] || arg;
          });
        }
      },
      MemberExpression: function MemberExpression(path) {
        var node = path.node;
        var file = path.hub.file;


        if (lodashObjs[node.object.name] && node.property.name == 'chain') {
          // Detect chaining via _.chain(value).
          throw new Error(CHAIN_ERROR);
        } else if (lodashObjs[node.object.name]) {
          // Transform _.foo() to _foo().
          path.replaceWith(importMethod(node.property.name, file));
        } else if (fpObjs[node.object.name]) {
          path.replaceWith(importMethod(node.property.name, file, 'fp'));
        }
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(path) {
        var node = path.node;
        var file = path.hub.file;


        if (!node.source) return;
        var isFp = node.source.value === 'lodash/fp';
        if (node.source.value === 'lodash' || isFp) {
          node.specifiers.forEach(function (specifier) {
            specifier.local = importMethod(specifier.local.name, file, isFp ? 'fp' : null);
          });
          node.source = null;
        }
      },


      // Various other (less common) ways to use a lodash specifier
      // This code doesn't apply to uses on a lodash object
      // only directly imported specifiers.

      // See #34
      Property: buildDeclaratorHandler('value'),
      // See #34
      VariableDeclarator: buildDeclaratorHandler('init'),

      // Allow things like `var x = y || _.noop` (see #28)
      LogicalExpression: buildExpressionHandler(['left', 'right']),

      // Allow things like `var x = y ? _.identity : _.noop` (see #28)
      ConditionalExpression: buildExpressionHandler(['test', 'consequent', 'alternate'])
    }
  };

  function buildDeclaratorHandler(prop) {
    return function (path) {
      var node = path.node;


      if (node[prop] != null) {
        var name = node[prop].name;
        if (specified[name]) {
          node[prop] = specified[name];
        } else if (fpSpecified[name]) {
          node[prop] = fpSpecified[name];
        }
      }
    };
  }

  function buildExpressionHandler(props) {
    return function (path) {
      var node = path.node;


      props.forEach(function (prop) {
        var expressionNode = node[prop],
            name = expressionNode.name;
        if (!t.isIdentifier(expressionNode)) return;

        if (specified[name]) {
          node[prop] = specified[name];
        } else if (fpSpecified[name]) {
          // Transform map() to fp.map() in order to avoid destructuring fp.
          node[prop] = fpSpecified[name];
        }
      });
    };
  }
};

var _lodashModules = require('./lodash-modules');

var _lodashModules2 = _interopRequireDefault(_lodashModules);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }